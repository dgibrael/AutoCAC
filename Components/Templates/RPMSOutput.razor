@implements IDisposable
@inject IJSRuntime JS
@using AutoCAC.Extensions
@using static RPMSService
@using AutoCAC.Models
@using Microsoft.EntityFrameworkCore
@inject IDbContextFactory<AutoCAC.Models.mainContext> DbFactory
@inject DialogService DialogService
@using AutoCAC.Components.Templates
@inject RPMSService RPMS
@if(!string.IsNullOrWhiteSpace(ButtonLabel))
{
    <button onclick="showDialog()" class="rz-button rz-button-md">@ButtonLabel</button>
}

<dialog id="RPMSOutputDiv" class="rz-w-75 rz-p-0">
    <RadzenRow>
        @ChildContent
    </RadzenRow>
    <RadzenRow>
        <div id="rpmsOutputTxtDiv" class="rz-w-100 rz-p-0"></div>
    </RadzenRow>
    <RadzenRow class="rz-mb-2">
        <RadzenButton Text="Clear History" Click="@(() => RPMS.ClearHistory())" ButtonStyle="ButtonStyle.Dark" />
        <RadzenButton Text="Download Terminal Contents" Click="DownloadReceived" />
    </RadzenRow>
    <RadzenRow>
        <button onclick="hideDialog()">Close</button>
    </RadzenRow>
</dialog>

@code {
    [Parameter] public RenderFragment ChildContent { get; set; }
    [Parameter] public string ButtonLabel { get; set; } = "Open RPMS Output";
    private CancellationTokenSource _pollingCts;
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await JS.ReinitXterm();
            await JS.WriteToXtermAsync(RPMS.Output.Buffered);
            if (RPMS.IsInMode(RPMSService.Modes.Disconnected))
            {
                RPMS.OpenConnection();
            }
        }
    }

    public async Task DownloadReceived()
    {
        await JS.DownloadXtermContentAsync();
    }

    private Func<Task> _queuedAction;

    public async Task RunWhenSignedIn(Func<Task> action)
    {
        // Store the action to execute after sign-in
        _queuedAction = action;

        // Always unsubscribe first (defensive cleanup)
        RPMS.UnSubscribeToModeChanged(HandleRunWhenSignedIn);

        if (RPMS.CurrentMode.SignedIn)
        {

            await _queuedAction();
            _queuedAction = null;
        }
        else
        {
            RPMS.SubscribeToModeChanged(HandleRunWhenSignedIn);
        }
    }

    private int TaskNumber { get; set; }
    private string TableName { get; set; }
    private Func<Task> _onUpdateComplete;
    private async Task UpdateFromRPMS(string tableName)
    {
        string menu = "";
        TableName = tableName;
        if (tableName != "OrderDialog") throw new Exception("menu option not found");
        switch (tableName)
        {
            case ("OrderDialog"):
                menu = "Order Dialog Update App";
                break;
        }
        await RPMS.GoToMenu(menu);
        await RPMS.SendAsync();
        await JS.DialogHide();
        var _outputLst = RPMS.Output.Buffered.Split("\r\n").ToList();
        var taskLine = _outputLst.FirstOrDefault(line => line.StartsWith("Task number:"));
        if (taskLine != null && int.TryParse(taskLine.Split(":").Last().Trim(), out int taskNumber))
        {
            TaskNumber = taskNumber;

            // Use the extension: fixed title/options, only pass Work
            await DialogService.LoadingDialogAsync(RunStatusWatcherAsync);
        }
    }
    private async Task RunStatusWatcherAsync(IProgress<double> progress)
    {
        _pollingCts?.Cancel();
        _pollingCts = new CancellationTokenSource();
        var token = _pollingCts.Token;

        try
        {
            while (!token.IsCancellationRequested)
            {
                var status = await DbFactory.GetFirstValueAsync($@"
                SELECT Status
                FROM DataImportStatus
                WHERE JobID = {TaskNumber}
                  AND TableName = {TableName}");

                switch (status)
                {
                    case "REQUESTED":
                        progress.Report(0);
                        break;

                    case "RECEIVING":
                        progress.Report(10);
                        break;

                    case "PARSING":
                        progress.Report(50);
                        break;

                    case "UPDATING":
                        progress.Report(75);
                        break;

                    case "DONE":
                        progress.Report(100);

                        await DbFactory.ExecuteSqlAsync(
                            $"DELETE FROM DataImportStatus WHERE JobID = {TaskNumber}");

                        if (_onUpdateComplete != null)
                            await _onUpdateComplete();

                        return; // exit polling loop
                }

                await Task.Delay(1000, token); // poll every 1 second
            }
        }
        catch (TaskCanceledException)
        {
            // expected on dispose / dialog close
        }
    }


    public async Task RunUpdateFromRPMS(string tableName, Func<Task> onComplete = null)
    {
        _onUpdateComplete = onComplete;
        await JS.DialogShow();
        await RunWhenSignedIn(() => UpdateFromRPMS(tableName));
    }

    private async void HandleRunWhenSignedIn()
    {
        if (_queuedAction is not null && RPMS.JustSignedIn)
        {
            try
            {
                await _queuedAction();
            }
            finally
            {
                RPMS.UnSubscribeToModeChanged(HandleRunWhenSignedIn);
                _queuedAction = null;
            }
        }
    }

    public void Dispose()
    {
        RPMS.ClearAllModeChangedSubscriptions();
        _queuedAction = null;
        _pollingCts?.Cancel();
        _pollingCts?.Dispose();
        _pollingCts = null;
    }
}